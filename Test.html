<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Golf Yardage → ESP32 e‑Paper (BLE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root { --headerH: 140px; }
    html, body { height:100%; margin:0; background:#0b0f14; color:#e9eef3; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #map { position:absolute; top:var(--headerH); left:0; right:0; bottom:0; }
    header { position:fixed; top:0; left:0; right:0; display:flex; flex-wrap:wrap; gap:8px 10px; padding:8px 12px; background:#111823; border-bottom:1px solid #1f2937; z-index:1000; }
    header .btn { background:#1f2937; color:#e9eef3; border:1px solid #2b3b50; padding:8px 10px; border-radius:10px; font-weight:700; font-size:14px; }
    header input, header select { background:#0e1520; color:#e9eef3; border:1px solid #233044; border-radius:8px; padding:6px 8px; }
    header select { min-width: 180px; }
    .row { display:flex; gap:10px; align-items:center; width:100%; }
    .row small { opacity:.8; }
    #yardage { position:fixed; bottom:12px; left:12px; right:12px; z-index:1000; background:#0e1520cc; backdrop-filter: blur(6px); border:1px solid #1f2937; border-radius:14px; padding:10px 12px; display:flex; align-items:center; justify-content:space-between; }
    #yardage .big { font-size:28px; font-weight:800; letter-spacing:0.5px; }
    #yardage .small { font-size:12px; opacity:0.9; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #2b3b50; border-radius:999px; font-size:12px; margin-left:6px; }
    .legend { position:fixed; right:12px; top:calc(var(--headerH) + 12px); background:#0e1520cc; border:1px solid #1f2937; border-radius:10px; padding:6px 8px; z-index:1000; font-size:12px; }
    .legend div { margin:4px 0; }
    label { font-size:12px; opacity:.9; }
    @media (max-width: 560px) {
      header .btn { padding:6px 8px; font-size:12px; }
      header input { width: 160px; }
      header select { min-width: 150px; }
    }
  </style>
</head>
<body>
  <header id="hdr">
    <div class="row">
      <button id="locBtn" class="btn">Locate</button>
      <button id="followBtn" class="btn">Follow: ON</button>
      <button id="debugBtn" class="btn">Debug: OFF</button>

      <select id="methodSelect" title="F/C/B method">
        <option value="ray">Ray via centroid</option>
        <option value="perimeter">Perimeter scan</option>
      </select>

      <select id="courseSelect" title="Fly to course">
        <option value="">— Fly to course —</option>
        <option value="36.5685,-121.9513,16">Pebble Beach (CA)</option>
        <option value="30.1980,-81.3931,16">TPC Sawgrass (FL)</option>
        <option value="33.5021,-82.0209,16">Augusta National (GA)</option>
        <option value="-37.9155,145.0417,16">Royal Melbourne West (AUS)</option>
      </select>
      <button id="flyBtn" class="btn">Fly</button>

      <button id="bleBtn" class="btn">Connect BLE</button>
      <button id="pingBtn" class="btn">Send Test</button>
      <small id="bleState">BLE: OFF</small>
      <small id="status" style="margin-left:auto;">Ready</small>
    </div>
    <div class="row">
      <label>Service:&nbsp;<input id="svcUuid" value="0000f00d-0000-1000-8000-00805f9b34fb"></label>
      <label>Char:&nbsp;<input id="chrUuid" value="0000f00e-0000-1000-8000-00805f9b34fb"></label>
      <label><input type="checkbox" id="asciiMode"> ASCII</label>
      <small>(Center = distance to green centroid. F/B per selected method. Auto-loading enabled.)</small>
    </div>
  </header>

  <div id="map"></div>

  <div id="yardage">
    <div>
      <div class="small">Hole <span id="holeRef">—</span> · <span id="methodLabel">ray</span></div>
      <div class="big"><span id="ydCenter">—</span> yd</div>
      <div class="small" id="trioRow" style="margin-top:4px; display:none">Front <span id="ydF">—</span> · Center <span id="ydC">—</span> · Back <span id="ydB">—</span></div>
      <div class="small" id="locStatus">Waiting for location…</div>
    </div>
    <div>
      <span class="pill" id="gpsAcc">— m</span>
      <span class="pill" id="speed">0.0 m/s</span>
    </div>
  </div>

  <div class="legend">
    <div><span style="display:inline-block;width:10px;height:10px;background:#7c3aed;border-radius:2px;margin-right:6px"></span> Hole centerline</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#10b981;border-radius:2px;margin-right:6px"></span> Green</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#f59e0b;border-radius:2px;margin-right:6px"></span> Tee</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#ef4444;border-radius:2px;margin-right:6px"></span> You</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#22c55e;border-radius:2px;margin-right:6px"></span> Front point</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#3b82f6;border-radius:2px;margin-right:6px"></span> Center (centroid)</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#f97316;border-radius:2px;margin-right:6px"></span> Back point</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // --- dynamic layout so the map always sits under the header ---
    const hdr = document.getElementById('hdr');
    const layout = () => document.documentElement.style.setProperty('--headerH', hdr.offsetHeight + 'px');
    new ResizeObserver(layout).observe(hdr); window.addEventListener('load', layout);

    // ===== MAP =====
    const map = L.map('map', { zoomSnap: 0.25, zoomControl: false });
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);

    const youIcon = L.circleMarker([0,0], { radius: 7, color: '#ef4444', weight: 2, fillColor:'#ef4444', fillOpacity:0.7 });
    const projIcon = L.circleMarker([0,0], { radius: 5, color: '#ffffff', weight: 1, fillColor:'#ffffff', fillOpacity:0.7 });

    const holesLayer = L.geoJSON(null, { style: { color:'#7c3aed', weight:3 } }).addTo(map);
    const greensLayer = L.geoJSON(null, { style: { color:'#10b981', weight:2, fillOpacity:0.1, fillColor:'#10b981' } }).addTo(map);
    const teesLayer = L.geoJSON(null, { style: { color:'#f59e0b', weight:2, fillOpacity:0.1, fillColor:'#f59e0b' } }).addTo(map);
    const debugGroup = L.layerGroup().addTo(map);

    let debugOn = false;
    const debugBtn = document.getElementById('debugBtn');
    debugBtn.onclick = () => {
      debugOn = !debugOn;
      debugBtn.textContent = 'Debug: ' + (debugOn ? 'ON' : 'OFF');
      if (!debugOn) debugGroup.clearLayers();
    };

    let follow = true;
    document.getElementById('followBtn').onclick = () => {
      follow = !follow;
      document.getElementById('followBtn').textContent = `Follow: ${follow? 'ON' : 'OFF'}`;
    };
    document.getElementById('locBtn').onclick = () => {
      if (lastPos) map.setView([lastPos.coords.latitude, lastPos.coords.longitude], 16, { animate:true });
    };

    function setStatus(msg) { document.getElementById('status').textContent = msg; }
    function setLocStatus(msg) { document.getElementById('locStatus').textContent = msg; }

    // ===== GPS =====
    let lastPos = null;
    function startGPS() {
      if (!('geolocation' in navigator)) { setLocStatus('Geolocation not supported'); return; }
      navigator.geolocation.watchPosition(onPos, onPosErr, { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
    }
    function onPos(pos) {
      lastPos = pos;
      const {latitude:lat, longitude:lon, accuracy:acc, speed} = pos.coords;
      document.getElementById('gpsAcc').textContent = (acc||0).toFixed(0) + ' m';
      document.getElementById('speed').textContent = ((speed||0)).toFixed(1) + ' m/s';
      youIcon.setLatLng([lat,lon]).addTo(map);
      if (follow) map.setView([lat,lon], Math.max(map.getZoom(), 16), { animate:true });
      updateYardage();
      // kick auto-fetcher
      maybeFetchCourse(lat, lon);
    }
    function onPosErr(err) { setLocStatus('Location error: ' + err.message + ' (use HTTPS)'); }

    // ===== Overpass (OSM) =====
    function bboxAround(lat, lon, meters) {
      const dLat = meters / 111320;
      const dLon = meters / (40075000 * Math.cos(lat * Math.PI/180) / 360);
      return [lat - dLat, lon - dLon, lat + dLat, lon + dLon];
    }
    function osmToGeoJSON(data) {
      const nodes = new Map();
      for (const el of data.elements) if (el.type==='node') nodes.set(el.id, [el.lat, el.lon]);
      const fc = { type:'FeatureCollection', features:[] };
      for (const el of data.elements) if (el.type==='way') {
        const coords = el.nodes.map(id => nodes.get(id)).filter(Boolean).map(([lat,lon]) => [lon,lat]);
        if (coords.length < 2) continue;
        const tags = el.tags || {};
        if (tags.golf === 'hole') fc.features.push({ type:'Feature', geometry:{ type:'LineString', coordinates:coords }, properties:{ type:'hole', ref: tags.ref||'', name: tags.name||'', id: el.id } });
        else if (tags.golf === 'green') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'green', ref: tags.ref||'', id: el.id } });
        else if (tags.golf === 'tee') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'tee', ref: tags.ref||'', id: el.id } });
        else if (tags.leisure === 'golf_course') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'course', name: tags.name||'', id: el.id } });
      }
      return fc;
    }
    let course = null;
    async function loadCourseAround(lat, lon) {
      setStatus('Loading course from OSM…');
      const bb = bboxAround(lat, lon, 1500);
      const q = 'data=' + encodeURIComponent(
`[out:json][timeout:25];
(
  way["leisure"="golf_course"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="hole"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="green"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="tee"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
);
(._;>;);
out body;`
      );
      const json = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8' }, body:q }).then(r=>r.json());
      const geo = osmToGeoJSON(json);
      const holes = geo.features.filter(f=>f.properties.type==='hole');
      const greens = geo.features.filter(f=>f.properties.type==='green');
      const tees = geo.features.filter(f=>f.properties.type==='tee');
      holesLayer.clearLayers(); greensLayer.clearLayers(); teesLayer.clearLayers();
      holesLayer.addData({ type:'FeatureCollection', features: holes });
      greensLayer.addData({ type:'FeatureCollection', features: greens });
      teesLayer.addData({ type:'FeatureCollection', features: tees });
      if (!holes.length && !greens.length) { setStatus('No golf features nearby'); return; }
      course = { holes, greens, tees };
      const all = L.featureGroup([holesLayer, greensLayer, teesLayer]);
      try { map.fitBounds(all.getBounds(), { padding:[20,20] }); } catch {}
      setStatus('Course loaded.');
      updateYardage();
    }

    // ===== Auto-loader (movement/time/cooldown) =====
    const FETCH_RADIUS_M = 1500;
    const REQUERY_MOVE_M = 400;           // re-fetch if moved > 400 m from last fetch center
    const REQUERY_MAX_AGE_MS = 12*60*1000; // or if older than 12 min
    const FETCH_COOLDOWN_MS = 45*1000;     // never more often than every 45 s

    let lastFetchCenter = null;  // [lat, lon]
    let lastFetchAt = 0;
    let fetching = false;

    function needFetch(lat, lon) {
      if (!lastFetchCenter) return true;
      const movedM = turf.distance(
        turf.point([lastFetchCenter[1], lastFetchCenter[0]]),
        turf.point([lon, lat]),
        { units: 'meters' }
      );
      const age = Date.now() - lastFetchAt;
      if (age > REQUERY_MAX_AGE_MS) return true;
      if (movedM > REQUERY_MOVE_M) return true;
      return false;
    }

    async function maybeFetchCourse(lat, lon) {
      if (fetching) return;
      const since = Date.now() - lastFetchAt;
      if (since < FETCH_COOLDOWN_MS) return;
      if (!needFetch(lat, lon)) return;

      fetching = true;
      try {
        await loadCourseAround(lat, lon);
        lastFetchCenter = [lat, lon];
        lastFetchAt = Date.now();
      } catch (e) {
        // Light backoff: push 'lastFetchAt' backwards so next attempt isn't immediate
        lastFetchAt = Date.now() - (FETCH_COOLDOWN_MS / 2);
        setStatus('Fetch failed; will retry later.');
      } finally {
        fetching = false;
      }
    }

    // ===== F/C/B methods =====
    function nearestHoleFeature(lat, lon) {
      if (!course || !course.holes.length) return null;
      const p = turf.point([lon, lat]);
      let best = null;
      for (const f of course.holes) {
        const d = turf.pointToLineDistance(p, f, { units:'meters' });
        if (!best || d < best.d) best = { f, d };
      }
      return best ? best.f : null;
    }

    function calcFCB_ray(green, mePoint) {
      try {
        const centroid = turf.centroid(green);
        const Cyd = turf.distance(mePoint, centroid, {units:'meters'}) * 1.0936133;
        const brg = turf.bearing(mePoint, centroid);
        const far = turf.destination(mePoint, 2, brg, { units:'kilometers' });
        let ray = turf.lineString([mePoint.geometry.coordinates, far.geometry.coordinates]);
        const boundary = turf.polygonToLine(green);
        let inter = turf.lineIntersect(ray, boundary);
        if (inter.features.length < 1) return { Cyd };
        const pts = inter.features.map(pt=>pt.geometry.coordinates).sort((a,b)=>
          turf.distance(mePoint, turf.point(a), {units:'meters'}) -
          turf.distance(mePoint, turf.point(b), {units:'meters'})
        );
        const Fpt = pts[0], Bpt = pts[pts.length - 1];
        const Fyd = turf.distance(mePoint, turf.point(Fpt), {units:'meters'}) * 1.0936133;
        const Byd = turf.distance(mePoint, turf.point(Bpt), {units:'meters'}) * 1.0936133;
        return { Fyd, Cyd, Byd, Fpt, Cpt: centroid.geometry.coordinates, Bpt, _ray: ray.geometry.coordinates };
      } catch { return null; }
    }

    function calcFCB_perimeter(green, mePoint) {
      try {
        const centroid = turf.centroid(green);
        const Cyd = turf.distance(mePoint, centroid, {units:'meters'}) * 1.0936133;
        const boundary = turf.flatten(turf.polygonToLine(green));
        let Fpt = null, Bpt = null, minM = Infinity, maxM = -Infinity;
        for (const feat of boundary.features) {
          const near = turf.nearestPointOnLine(feat, mePoint);
          const dm = turf.distance(mePoint, near, { units:'meters' });
          if (dm < minM) { minM = dm; Fpt = near.geometry.coordinates; }
          for (const c of feat.geometry.coordinates) {
            const dv = turf.distance(mePoint, turf.point(c), { units:'meters' });
            if (dv > maxM) { maxM = dv; Bpt = c; }
          }
        }
        const Fyd = minM * 1.0936133;
        const Byd = maxM * 1.0936133;
        return { Fyd, Cyd, Byd, Fpt, Cpt: centroid.geometry.coordinates, Bpt };
      } catch { return null; }
    }

    function pickGreenForHole(hole) {
      if (!course || !course.greens?.length) return null;
      const coords = hole.geometry.coordinates;
      const end = coords[coords.length - 1];
      const endPt = turf.point(end);
      let best=null;
      for (const g of course.greens) {
        const c = turf.centroid(g);
        const d = turf.distance(c, endPt, { units:'meters' });
        if (!best || d < best.d) best = { g, d };
      }
      return best ? best.g : null;
    }

    // ===== BLE =====
    let bleDevice=null, bleChar=null, lastBleSend=0, lastSent={y:-1,h:-1};
    function getUUIDs(){ return { service: svcUuid.value.trim(), char: chrUuid.value.trim(), ascii: asciiMode.checked }; }
    async function connectBLE() {
      if (!navigator.bluetooth) { setStatus('Web Bluetooth not supported'); return; }
      const { service, char } = getUUIDs();
      try {
        setStatus('Requesting BLE device…');
        bleDevice = await navigator.bluetooth.requestDevice({ filters:[{ services:[service] }], optionalServices:[service] });
        bleDevice.addEventListener('gattserverdisconnected', ()=>{ bleState.textContent='BLE: DISC'; bleChar=null; });
        const server = await bleDevice.gatt.connect();
        const svc = await server.getPrimaryService(service);
        bleChar = await svc.getCharacteristic(char);
        bleState.textContent='BLE: ON'; setStatus('BLE connected.');
      } catch(e){ setStatus('BLE error: '+e.message); }
    }
    document.getElementById('bleBtn').onclick = connectBLE;
    async function sendBLE(holeNum, yards) {
      if (!bleChar) return;
      const now = Date.now();
      if (now - lastBleSend < 900) return;
      if (yards === lastSent.y && holeNum === lastSent.h) return;
      const { ascii } = getUUIDs();
      try{
        if (ascii) {
          const s = `H${holeNum||0} ${Math.max(0,Math.min(9999,Math.round(yards)))}\n`;
          await bleChar.writeValue(new TextEncoder().encode(s));
        } else {
          const buf=new ArrayBuffer(4), dv=new DataView(buf);
          const y = Math.max(0, Math.min(65535, Math.round(yards)));
          dv.setUint16(0, y, true); dv.setUint8(2, Math.max(0,Math.min(255,holeNum||0))); dv.setUint8(3, 0);
          if (bleChar.writeValueWithoutResponse) await bleChar.writeValueWithoutResponse(buf); else await bleChar.writeValue(buf);
        }
        lastBleSend = now; lastSent = { y: Math.round(yards), h: holeNum||0 };
      }catch(e){ setStatus('BLE write failed: '+e.message); }
    }
    document.getElementById('pingBtn').onclick = ()=> sendBLE(99,321);

    // ===== Update loop =====
    function updateYardage() {
      if (!lastPos || !course) return;
      const lat = lastPos.coords.latitude, lon = lastPos.coords.longitude;
      const me = turf.point([lon,lat]);

      const hole = nearestHoleFeature(lat, lon);
      if (!hole) { setStatus('No hole geometry nearby'); return; }
      const green = pickGreenForHole(hole);

      const method = document.getElementById('methodSelect').value;
      document.getElementById('methodLabel').textContent = method;

      let FCB = null;
      if (green) {
        FCB = (method === 'perimeter') ? calcFCB_perimeter(green, me) : calcFCB_ray(green, me);
      } else {
        const snapped = turf.nearestPointOnLine(hole, me);
        const lineEnd = turf.point(hole.geometry.coordinates.at(-1));
        const Cyd = turf.length(turf.lineSlice(snapped, lineEnd, hole), {units:'meters'}) * 1.0936133;
        FCB = { Fyd: Cyd, Cyd, Byd: Cyd };
      }

      const holeRef = parseInt(hole.properties.ref||'0') || 0;
      document.getElementById('holeRef').textContent = holeRef || '?';

      if (FCB && isFinite(FCB.Cyd)) {
        const yds = Math.round(FCB.Cyd);
        document.getElementById('ydCenter').textContent = yds;
        document.getElementById('ydC').textContent = yds;
        document.getElementById('trioRow').style.display = 'block';
        if (isFinite(FCB.Fyd)) document.getElementById('ydF').textContent = Math.round(FCB.Fyd);
        if (isFinite(FCB.Byd)) document.getElementById('ydB').textContent = Math.round(FCB.Byd);
        if (bleChar) sendBLE(holeRef, yds); // send center
      } else {
        document.getElementById('ydCenter').textContent = '—';
        document.getElementById('trioRow').style.display = 'none';
      }
      setLocStatus('Tracking…');

      // Debug overlay
      debugGroup.clearLayers();
      if (debugOn && FCB) {
        const meLL = [lat, lon];
        if (FCB.Fpt) {
          L.polyline([meLL, [FCB.Fpt[1], FCB.Fpt[0]]], { color:'#22c55e', weight:2 }).addTo(debugGroup);
          L.circleMarker([FCB.Fpt[1], FCB.Fpt[0]], { radius:6, color:'#22c55e', weight:2, fillColor:'#22c55e', fillOpacity:0.9 }).addTo(debugGroup).bindTooltip('Front');
        }
        if (FCB.Cpt) {
          L.circleMarker([FCB.Cpt[1], FCB.Cpt[0]], { radius:5, color:'#3b82f6', weight:2, fillColor:'#3b82f6', fillOpacity:0.9 }).addTo(debugGroup).bindTooltip('Center');
        }
        if (FCB.Bpt) {
          L.polyline([meLL, [FCB.Bpt[1], FCB.Bpt[0]]], { color:'#f97316', weight:2, dashArray:'6,4' }).addTo(debugGroup);
          L.circleMarker([FCB.Bpt[1], FCB.Bpt[0]], { radius:6, color:'#f97316', weight:2, fillColor:'#f97316', fillOpacity:0.9 }).addTo(debugGroup).bindTooltip('Back');
        }
        if (FCB._ray) {
          const rayLatLngs = FCB._ray.map(([x,y])=>[y,x]);
          L.polyline(rayLatLngs, { color:'#00e5ff', weight:2, opacity:0.8, dashArray:'2,4' }).addTo(debugGroup);
        }
      }

      // Projected point on hole centerline (just a helper marker)
      const snapped = turf.nearestPointOnLine(hole, me);
      projIcon.setLatLng([snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]]).addTo(map);
    }

    // Fly-to courses
    document.getElementById('flyBtn').onclick = () => {
      const sel = document.getElementById('courseSelect').value;
      if (!sel) return;
      const [latS, lonS, zoomS] = sel.split(',');
      const lat = parseFloat(latS), lon = parseFloat(lonS), zoom = parseInt(zoomS||'16',10);
      map.flyTo([lat, lon], zoom, { animate:true });
      onPos({ coords: { latitude: lat, longitude: lon, accuracy: 5, speed: 0 } });
      // force a fetch at this location
      lastFetchCenter = null;
      maybeFetchCourse(lat, lon);
    };

    // Tap-to-set position fallback (for testing without GPS/HTTPS)
    map.on('click', (e) => {
      const lat = e.latlng.lat, lon = e.latlng.lng;
      onPos({ coords: { latitude: lat, longitude: lon, accuracy:5, speed:0 } });
      maybeFetchCourse(lat, lon);
    });

    // Init
    map.setView([40.0,-100.0], 3);
    startGPS();

    // UI tick: yardage render; also re-check fetch conditions
    setInterval(()=>{
      if (course && lastPos) updateYardage();
      if (lastPos) maybeFetchCourse(lastPos.coords.latitude, lastPos.coords.longitude);
    }, 1200);

    // keep map under header as header wraps on mobile
    layout();
  </script>
</body>
</html>
