<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Golf Yardage → ESP32 e‑Paper (BLE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root { --headerH: 128px; }
    html, body { height:100%; margin:0; background:#0b0f14; color:#e9eef3; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #map { position:absolute; top:var(--headerH); left:0; right:0; bottom:0; }
    header { position:fixed; top:0; left:0; right:0; display:flex; flex-wrap:wrap; gap:8px 10px; padding:8px 12px; background:#111823; border-bottom:1px solid #1f2937; z-index:1000; }
    header .btn { background:#1f2937; color:#e9eef3; border:1px solid #2b3b50; padding:8px 10px; border-radius:10px; font-weight:700; font-size:14px; }
    header input, header select { background:#0e1520; color:#e9eef3; border:1px solid #233044; border-radius:8px; padding:6px 8px; }
    header select { min-width: 200px; }
    .row { display:flex; gap:10px; align-items:center; width:100%; }
    .row small { opacity:.8; }
    #yardage { position:fixed; bottom:12px; left:12px; right:12px; z-index:1000; background:#0e1520cc; backdrop-filter: blur(6px); border:1px solid #1f2937; border-radius:14px; padding:10px 12px; display:flex; align-items:center; justify-content:space-between; }
    #yardage .big { font-size:28px; font-weight:800; letter-spacing:0.5px; }
    #yardage .small { font-size:12px; opacity:0.8; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #2b3b50; border-radius:999px; font-size:12px; margin-left:6px; }
    .legend { position:fixed; right:12px; top:calc(var(--headerH) + 12px); background:#0e1520cc; border:1px solid #1f2937; border-radius:10px; padding:6px 8px; z-index:1000; font-size:12px; }
    .legend div { margin:4px 0; }
    label { font-size:12px; opacity:.9; }
    @media (max-width: 520px) {
      header .btn { padding:6px 8px; font-size:12px; }
      header input { width: 170px; }
      header select { min-width: 160px; }
    }
  </style>
</head>
<body>
  <header id="hdr">
    <div class="row">
      <button id="locBtn" class="btn">Locate</button>
      <button id="loadBtn" class="btn">Load</button>
      <button id="followBtn" class="btn">Follow: ON</button>
      <button id="debugBtn" class="btn">Debug: OFF</button>

      <select id="courseSelect" title="Fly to course">
        <option value="">— Fly to course —</option>
        <option value="36.5685,-121.9513,16">Pebble Beach (CA)</option>
        <option value="30.1980,-81.3931,16">TPC Sawgrass (FL)</option>
        <option value="33.5021,-82.0209,16">Augusta National (GA)</option>
        <option value="-37.9155,145.0417,16">Royal Melbourne West (AUS)</option>
      </select>
      <button id="flyBtn" class="btn">Fly</button>

      <button id="bleBtn" class="btn">Connect BLE</button>
      <button id="pingBtn" class="btn">Send Test</button>
      <small id="bleState">BLE: OFF</small>
      <small id="status" style="margin-left:auto;">Ready</small>
    </div>
    <div class="row">
      <label>Service:&nbsp;<input id="svcUuid" value="0000f00d-0000-1000-8000-00805f9b34fb"></label>
      <label>Char:&nbsp;<input id="chrUuid" value="0000f00e-0000-1000-8000-00805f9b34fb"></label>
      <label><input type="checkbox" id="asciiMode"> ASCII</label>
      <small>(Big number = center. F/B uses green boundary.)</small>
    </div>
  </header>

  <div id="map"></div>

  <div id="yardage">
    <div>
      <div class="small">Hole <span id="holeRef">—</span></div>
      <div class="big"><span id="ydCenter">—</span> yd <span id="fb" class="small" style="display:none">(<span id="ydF">—</span> F / <span id="ydB">—</span> B)</span></div>
      <div class="small" id="locStatus">Waiting for location…</div>
    </div>
    <div>
      <span class="pill" id="gpsAcc">— m</span>
      <span class="pill" id="speed">0.0 m/s</span>
    </div>
  </div>

  <div class="legend">
    <div><span style="display:inline-block;width:10px;height:10px;background:#7c3aed;border-radius:2px;margin-right:6px"></span> Hole centerline</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#10b981;border-radius:2px;margin-right:6px"></span> Green</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#f59e0b;border-radius:2px;margin-right:6px"></span> Tee</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#ef4444;border-radius:2px;margin-right:6px"></span> You</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#22c55e;border-radius:2px;margin-right:6px"></span> Front point</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#f97316;border-radius:2px;margin-right:6px"></span> Back point</div>
    <div><span style="display:inline-block;width:10px;height:10px;background:#00e5ff;border-radius:2px;margin-right:6px"></span> Debug lines</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // --- dynamic layout so the map always sits under the header ---
    const hdr = document.getElementById('hdr');
    const layout = () => document.documentElement.style.setProperty('--headerH', hdr.offsetHeight + 'px');
    new ResizeObserver(layout).observe(hdr); window.addEventListener('load', layout);

    // ===== MAP =====
    const map = L.map('map', { zoomSnap: 0.25, zoomControl: false });
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);

    const youIcon = L.circleMarker([0,0], { radius: 7, color: '#ef4444', weight: 2, fillColor:'#ef4444', fillOpacity:0.7 });
    const projIcon = L.circleMarker([0,0], { radius: 5, color: '#ffffff', weight: 1, fillColor:'#ffffff', fillOpacity:0.7 });

    const holesLayer = L.geoJSON(null, { style: { color:'#7c3aed', weight:3 } }).addTo(map);
    const greensLayer = L.geoJSON(null, { style: { color:'#10b981', weight:2, fillOpacity:0.1, fillColor:'#10b981' } }).addTo(map);
    const teesLayer = L.geoJSON(null, { style: { color:'#f59e0b', weight:2, fillOpacity:0.1, fillColor:'#f59e0b' } }).addTo(map);
    const debugGroup = L.layerGroup().addTo(map);

    let debugOn = false;
    document.getElementById('debugBtn').onclick = () => {
      debugOn = !debugOn;
      document.getElementById('debugBtn').textContent = 'Debug: ' + (debugOn ? 'ON' : 'OFF');
      if (!debugOn) debugGroup.clearLayers();
    };

    let follow = true;
    document.getElementById('followBtn').onclick = () => {
      follow = !follow;
      document.getElementById('followBtn').textContent = `Follow: ${follow? 'ON' : 'OFF'}`;
    };
    document.getElementById('locBtn').onclick = () => { if (lastPos) map.setView([lastPos.coords.latitude, lastPos.coords.longitude], 16, { animate:true }); };

    function setStatus(msg) { document.getElementById('status').textContent = msg; }
    function setLocStatus(msg) { document.getElementById('locStatus').textContent = msg; }

    // ===== GPS =====
    let lastPos = null;
    function startGPS() {
      if (!('geolocation' in navigator)) { setLocStatus('Geolocation not supported'); return; }
      navigator.geolocation.watchPosition(onPos, onPosErr, { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
    }
    function onPos(pos) {
      lastPos = pos;
      const {latitude:lat, longitude:lon, accuracy:acc, speed} = pos.coords;
      document.getElementById('gpsAcc').textContent = (acc||0).toFixed(0) + ' m';
      document.getElementById('speed').textContent = ((speed||0)).toFixed(1) + ' m/s';
      youIcon.setLatLng([lat,lon]).addTo(map);
      if (follow) map.setView([lat,lon], Math.max(map.getZoom(), 16), { animate:true });
      updateYardage();
    }
    function onPosErr(err) { setLocStatus('Location error: ' + err.message + ' (use HTTPS)'); }

    // ===== Overpass =====
    function bboxAround(lat, lon, meters) {
      const dLat = meters / 111320;
      const dLon = meters / (40075000 * Math.cos(lat * Math.PI/180) / 360);
      return [lat - dLat, lon - dLon, lat + dLat, lon + dLon];
    }
    function osmToGeoJSON(data) {
      const nodes = new Map();
      for (const el of data.elements) if (el.type==='node') nodes.set(el.id, [el.lat, el.lon]);
      const fc = { type:'FeatureCollection', features:[] };
      for (const el of data.elements) if (el.type==='way') {
        const coords = el.nodes.map(id => nodes.get(id)).filter(Boolean).map(([lat,lon]) => [lon,lat]);
        if (coords.length < 2) continue;
        const tags = el.tags || {};
        if (tags.golf === 'hole') fc.features.push({ type:'Feature', geometry:{ type:'LineString', coordinates:coords }, properties:{ type:'hole', ref: tags.ref||'', name: tags.name||'', id: el.id } });
        else if (tags.golf === 'green') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'green', ref: tags.ref||'', id: el.id } });
        else if (tags.golf === 'tee') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'tee', ref: tags.ref||'', id: el.id } });
        else if (tags.leisure === 'golf_course') fc.features.push({ type:'Feature', geometry:{ type:'Polygon', coordinates:[coords] }, properties:{ type:'course', name: tags.name||'', id: el.id } });
      }
      return fc;
    }
    let course = null;
    async function loadCourseAround(lat, lon) {
      setStatus('Loading course from OSM…');
      const bb = bboxAround(lat, lon, 1500);
      const q = 'data=' + encodeURIComponent(
`[out:json][timeout:25];
(
  way["leisure"="golf_course"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="hole"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="green"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
  way["golf"="tee"](${bb[0]},${bb[1]},${bb[2]},${bb[3]});
);
(._;>;);
out body;`
      );
      const json = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8' }, body:q }).then(r=>r.json());
      const geo = osmToGeoJSON(json);
      const holes = geo.features.filter(f=>f.properties.type==='hole');
      const greens = geo.features.filter(f=>f.properties.type==='green');
      const tees = geo.features.filter(f=>f.properties.type==='tee');
      holesLayer.clearLayers(); greensLayer.clearLayers(); teesLayer.clearLayers();
      holesLayer.addData({ type:'FeatureCollection', features: holes });
      greensLayer.addData({ type:'FeatureCollection', features: greens });
      teesLayer.addData({ type:'FeatureCollection', features: tees });
      if (!holes.length && !greens.length) { setStatus('No golf features nearby'); return; }
      course = { holes, greens, tees };
      const all = L.featureGroup([holesLayer, greensLayer, teesLayer]);
      try { map.fitBounds(all.getBounds(), { padding:[20,20] }); } catch {}
      setStatus('Course loaded.');
      updateYardage();
    }
    document.getElementById('loadBtn').onclick = () => { if (!lastPos) setStatus('Need GPS first'); else loadCourseAround(lastPos.coords.latitude, lastPos.coords.longitude).catch(e=>setStatus(e.message||String(e))); };

    function nearestHoleFeature(lat, lon) {
      if (!course || !course.holes.length) return null;
      const p = turf.point([lon, lat]);
      let best = null;
      for (const f of course.holes) {
        const d = turf.pointToLineDistance(p, f, { units:'meters' });
        if (!best || d < best.d) best = { f, d };
      }
      return best ? best.f : null;
    }

    function pickGreenForHole(hole) {
      if (!course || !course.greens?.length) return null;
      const coords = hole.geometry.coordinates;
      const end = coords[coords.length - 1];
      const endPt = turf.point(end);
      let best=null;
      for (const g of course.greens) {
        const c = turf.centroid(g);
        const d = turf.distance(c, endPt, { units:'meters' });
        if (!best || d < best.d) best = { g, d };
      }
      return best ? best.g : null;
    }

    // ----- New robust F/B: perimeter scan -----
    function frontBackPerimeter(green, mePoint) {
      try {
        const boundary = turf.flatten(turf.polygonToLine(green)); // FeatureCollection of LineStrings
        let frontPt = null, minM = Infinity;
        let backPt = null,  maxM = -Infinity;

        for (const feat of boundary.features) {
          // Nearest point ON LINE for front
          const near = turf.nearestPointOnLine(feat, mePoint);
          const dm = turf.distance(mePoint, near, { units:'meters' });
          if (dm < minM) { minM = dm; frontPt = near.geometry.coordinates; }

          // Farthest vertex for back (simple & robust)
          for (const c of feat.geometry.coordinates) {
            const dv = turf.distance(mePoint, turf.point(c), { units:'meters' });
            if (dv > maxM) { maxM = dv; backPt = c; }
          }
        }
        if (!frontPt || !backPt) return null;
        return {
          Fyd: minM * 1.0936133,
          Byd: maxM * 1.0936133,
          frontPt, backPt
        };
      } catch { return null; }
    }

    // ===== BLE =====
    let bleDevice=null, bleChar=null, lastBleSend=0, lastSent={y:-1,h:-1};
    function getUUIDs(){ return { service: svcUuid.value.trim(), char: chrUuid.value.trim(), ascii: asciiMode.checked }; }
    async function connectBLE() {
      if (!navigator.bluetooth) { setStatus('Web Bluetooth not supported'); return; }
      const { service, char } = getUUIDs();
      try {
        setStatus('Requesting BLE device…');
        bleDevice = await navigator.bluetooth.requestDevice({ filters:[{ services:[service] }], optionalServices:[service] });
        bleDevice.addEventListener('gattserverdisconnected', ()=>{ bleState.textContent='BLE: DISC'; bleChar=null; });
        const server = await bleDevice.gatt.connect();
        const svc = await server.getPrimaryService(service);
        bleChar = await svc.getCharacteristic(char);
        bleState.textContent='BLE: ON'; setStatus('BLE connected.');
      } catch(e){ setStatus('BLE error: '+e.message); }
    }
    document.getElementById('bleBtn').onclick = connectBLE;
    async function sendBLE(holeNum, yards) {
      if (!bleChar) return;
      const now = Date.now();
      if (now - lastBleSend < 900) return;
      if (yards === lastSent.y && holeNum === lastSent.h) return;
      const { ascii } = getUUIDs();
      try{
        if (ascii) {
          const s = `H${holeNum||0} ${Math.max(0,Math.min(9999,Math.round(yards)))}\n`;
          await bleChar.writeValue(new TextEncoder().encode(s));
        } else {
          const buf=new ArrayBuffer(4), dv=new DataView(buf);
          const y = Math.max(0, Math.min(65535, Math.round(yards)));
          dv.setUint16(0, y, true); dv.setUint8(2, Math.max(0,Math.min(255,holeNum||0))); dv.setUint8(3, 0);
          if (bleChar.writeValueWithoutResponse) await bleChar.writeValueWithoutResponse(buf); else await bleChar.writeValue(buf);
        }
        lastBleSend = now; lastSent = { y: Math.round(yards), h: holeNum||0 };
      }catch(e){ setStatus('BLE write failed: '+e.message); }
    }
    document.getElementById('pingBtn').onclick = ()=> sendBLE(99,321);

    // ===== Update loop =====
    function updateYardage() {
      if (!lastPos || !course) return;
      const lat = lastPos.coords.latitude, lon = lastPos.coords.longitude;
      const me = turf.point([lon,lat]);

      const hole = nearestHoleFeature(lat, lon);
      if (!hole) { setStatus('No hole geometry nearby'); return; }

      const green = (course.greens||[]).length ? pickGreenForHole(hole) : null;

      // Big number = distance to centroid (center)
      const centroid = green ? turf.centroid(green) : null;
      let centerYd;
      if (centroid) {
        centerYd = turf.distance(me, centroid, {units:'meters'}) * 1.0936133;
      } else {
        const snapped = turf.nearestPointOnLine(hole, me);
        const lineEnd = turf.point(hole.geometry.coordinates.at(-1));
        centerYd = turf.length(turf.lineSlice(snapped, lineEnd, hole), {units:'meters'}) * 1.0936133;
      }

      const holeRef = parseInt(hole.properties.ref||'0') || 0;
      const yds = Math.round(centerYd);
      document.getElementById('ydCenter').textContent = isFinite(yds) ? yds : '—';
      document.getElementById('holeRef').textContent = holeRef || '?';

      // Front/Back from perimeter
      const fb = green ? frontBackPerimeter(green, me) : null;
      const fbBox = document.getElementById('fb');
      if (fb && isFinite(fb.Fyd) && isFinite(fb.Byd)) {
        fbBox.style.display = 'inline';
        document.getElementById('ydF').textContent = Math.round(fb.Fyd);
        document.getElementById('ydB').textContent = Math.round(fb.Byd);
      } else {
        fbBox.style.display = 'none';
      }

      setLocStatus('Tracking…');

      // Debug overlays
      debugGroup.clearLayers();
      if (debugOn && fb) {
        const meLL = [lat, lon];
        if (fb.frontPt) L.polyline([meLL, [fb.frontPt[1], fb.frontPt[0]]], { color:'#22c55e', weight:2 }).addTo(debugGroup);
        if (fb.backPt)  L.polyline([meLL, [fb.backPt[1],  fb.backPt[0]]], { color:'#f97316', weight:2, dashArray:'6,4' }).addTo(debugGroup);
      }

      // Push to BLE
      if (bleChar && isFinite(yds)) sendBLE(holeRef, yds);
    }

    // Fly-to courses
    document.getElementById('flyBtn').onclick = () => {
      const sel = document.getElementById('courseSelect').value;
      if (!sel) return;
      const [latS, lonS, zoomS] = sel.split(',');
      const lat = parseFloat(latS), lon = parseFloat(lonS), zoom = parseInt(zoomS||'16',10);
      map.flyTo([lat, lon], zoom, { animate:true });
      // also set a fake position so you can test without GPS at that spot
      onPos({ coords: { latitude: lat, longitude: lon, accuracy: 5, speed: 0 } });
      loadCourseAround(lat, lon).catch(e=>setStatus(e.message||String(e)));
    };

    // Tap-to-set position fallback (for testing without GPS/HTTPS)
    map.on('click', (e) => onPos({ coords: { latitude:e.latlng.lat, longitude:e.latlng.lng, accuracy:5, speed:0 } }));

    // Init
    map.setView([40.0,-100.0], 3);
    startGPS();

    // After GPS, load once; then update ~1.2 Hz
    let autoLoaded=false;
    setInterval(()=>{
      if (!autoLoaded && lastPos && !course) { autoLoaded = true; loadCourseAround(lastPos.coords.latitude, lastPos.coords.longitude).catch(e=>setStatus(e.message||String(e))); }
      if (course && lastPos) updateYardage();
    }, 1200);

    // keep map under header as header wraps on mobile
    layout();
  </script>
</body>
</html>
